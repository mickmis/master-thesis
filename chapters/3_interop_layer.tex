% todo: information if someone wants to make a resource compatible with GB: what kind of things it should expose
% todo: diagram include third-party for auth
% todo: uniform vocab (concepts / entities) (backend / back end)
% todo: depth with a parameter?
% todo: backgorund about oidc (client id, etc.)
% todo: oauth2/oidc/jwt/jwk cite as rfc

\chapter{Interoperability Layer for Clinical Research Systems}

% --> achieves compatibility with transmart and i2b2

In this chapter we are presenting the solution for the first objective of the project:
setting up an interoperability layer for the main open-source clinical research systems, namely tranSMART, i2b2 and their respective derivations.
The general design of the solution is first presented, then the steps that are required to implement this system are explained.

\section{Design of the Interoperability Layer}
% todo: integrate running example? the query below works well?

This section describes in details the design of our solution. %chosen chapter~\ref{sec:sysdesign}.
It aims to allow the cohort explorer UI Glowing Bear to support the following systems:
\begin{itemize}
    \item i2b2
    \item SHRINE 
    \item tranSMART 17.1 (REST API v2)
    %\item tranSMART 16.2 (REST API v1)
\end{itemize}

Because of the fundamental differences in the APIs, it is not possible to browse and query several resources at the same time, we thus restrict the scope to using one system at the time, while having compatibility with different ones.
After being logged in, the user is able to choose from which resource do the queries.
A resource is defined as an instance of one the supported systems.

Figure~\ref{fig:sysdiagramobj1} shows the system diagram after completion of the objective 1.
We can see that IRCT acts as a back end component for Glowing Bear, all its communications go through it using the PIC-SURE API.
IRCT communicates with the native APIs of the back end systems.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{figures/sys_diagram_obj1.png}
    \caption{System diagram of objective 1: Interoperability layer for a common front end for clinical research platforms.}
    \label{fig:sysdiagramobj1}
\end{figure}


\subsection{General Workflow}
The general workflow of the system starts in Glowing Bear.
%The users logs in using XXX TBD.
Then a specific IRCT resource is selected for the rest of the operations of this session.
The user browses the tree of entities to construct query constraints using the PIC-SURE API.
Each resource exposes this tree however it wants, but always within sticking to a common interface.
When the constraints for selecting patients are established, the user chooses what data to export.
During those last operations, the counts corresponding to the query are updated dynamically with background requests to IRCT, which itself does requests to the resources with their native API.
Finally once the full query is constructed, the user executes the final query and is able to download the results, again using one common API.


\subsection{Access Management}

The authentication is delegated to a third-party using the OpenID Connect protocol~\cite{todo}, here the third-party we use is Keycloak but it could be swapped with any software implementing the same protocol.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{figures/access_mgmt.png}
    \caption{Diagram of the access management design.}
    \label{fig:accessmgmt}
\end{figure}

Figure~\ref{fig:accessmgmt} shows the high-level picture of the access management in our solution, which revolves around Keycloak.
All components, i.e. IRCT and the back ends, verify the JSON Web Token embedded in the requests to authenticate the user and enforce its authorizations. %todo: cite JWT

% steps
The steps are:
\begin{enumerate}
    \item The client performs the authentication with Keycloak, with the client ID of the back end (which is set up to be the same as the IRCT resource name), and get a JSON Web Token containing the user authorizations
    \item Glowing Bear makes HTTP requests to IRCT, with the JWT embedded in the headers.
    \item IRCT verify the JWT using the public key of Keycloak. 
    The JWT contains the identifier of the signing key, which IRCT uses to requests the corresponding public key to Keycloak (and is cached to minimize the requests) and then verify the signature.
    \item The authenticated request is forwarded to the back end the user is using, the token remains the same.
    \item The back end verify the JWT using the same method as IRCT, and is responsible to enforce its own authorizations, which are contained in the JWT.
\end{enumerate}

% about client ids
Note that the JWT are verified twice in this design. 
The JWT contains the client identifier, which must be verified by the OIDC clients.
IRCT do not have its own client identifier, but verify that the identifier matches the one of the back end.
The back end has its own client identifier, and for the sake of consistency we enforce that the IRCT resource name is the same as the client identifier.

% todo: add small ccl on why this is good, and some analysis

\subsection{Glowing Bear Queries}

One of the main implementation challenge is replacing in Glowing Bear the tranSMART API v2 by the PIC-SURE API.
In Glowing Bear, all the operations the user undertakes have the objective of constructing a query to select data.
In order to give an overview of the goal of the changes in Glowing Bear, see below an example of a query with the tranSMART API v2 and its equivalent using the PIC-SURE API.
The query exports the gender for all patients aged from 20 to 25 years old in the \emph{CATEGORICAL\_VALUES} study.

\newpage
\paragraph*{tranSMART API v2 Example Query}
\begin{verbatim}
POST /export/<id>/run
{
"constraint": {
"type": "and",
"args": [
  {
    "type": "and",
    "args": [ {
      "type": "subselection", "dimension": "patient",
      "constraint": {
        "type": "and",
        "args": [
          {
            "type": "and",
            "args": [
              { "type": "concept", "conceptCode": "CV:DEM:AGE" },
              { "type": "value", "valueType": "NUMERIC", "operator": ">=", "value": 20 },
              { "type": "value", "valueType": "NUMERIC", "operator": "<=", "value": 25 }
            ]
          },
          { "type": "study_name", "studyId": "CATEGORICAL_VALUES" }
        ]
    } } ]
  }, {
    "type": "or",
    "args": [
      {
        "type": "and",
        "args": [
          { "type": "concept", "conceptCode": "CV:DEM:SEX:F" },
          { "type": "study_name", "studyId": "CATEGORICAL_VALUES" }
        ]
      }, {
        "type": "and",
        "args": [
          { "type": "concept", "conceptCode": "CV:DEM:SEX:M" },
          { "type": "study_name", "studyId": "CATEGORICAL_VALUES" }
        ]
      } ]
  }
]
},
"elements": 
  [{ "dataType": "clinical", "format": "TSV", "dataView": "default" }]
}
\end{verbatim}

\newpage
\paragraph*{PIC-SURE API Equivalent Query}
\begin{verbatim}
POST /queryService/runQuery
{
  "select": [ {
    "operation": "EXPORT",
    "fields": { "data": "clinical", "file": "TSV" }
  }, {
    "field": {
      "pui": "/<resource>/Public Studies/CATEGORICAL_VALUES/Demography/Gender/Male/",
      "dataType": "ENUM_VALUE"
    }
  }, {
    "field": {
      "pui": "/<resource>/Public Studies/CATEGORICAL_VALUES/Demography/Gender/Female/",
      "dataType": "ENUM_VALUE"
    }
  } ],
  "where": [
    {
      "field": {
        "pui": "/<resource>/Public Studies/CATEGORICAL_VALUES/Demography/Age/",
        "dataType": "INTEGER"
      },
      "predicate": "CONSTRAIN_VALUE_NUMERIC",
      "fields": { "OPERATOR": ">=", "CONSTRAINT": "20" }
    }, {
      "field": {
        "pui": "/<resource>/Public Studies/CATEGORICAL_VALUES/Demography/Age/",
        "dataType": "INTEGER"
      },
      "predicate": "CONSTRAIN_VALUE_NUMERIC",
      "fields": { "OPERATOR": "<=", "CONSTRAINT": "25" },
      "logicalOperator": "AND"
    }, {
      "field": {
        "pui": "/<resource>/Public Studies/CATEGORICAL_VALUES/",
        "dataType": "STUDY"
      },
      "predicate": "CONTAINS",
      "logicalOperator": "AND"
    } 
  ],
  "alias": "My query"
}
\end{verbatim}

We observe that the tranSMART API v2 uses a \emph{subselection} of patients to specify the constraints, and then the additional constraints (linked together by an \emph{OR}, and with the subselection by an \emph{AND}) are used to select the data to be exported.
To pursue the same objective, PIC-SURE uses \emph{where} clauses for specifying constraints and \emph{select} clauses to select the data to be exported.


\subsection{Back End Systems}

% baseline
IRCT communicates with all of the supported back end systems using their native APIs.
The compatible resources expose their tree of concept of concepts, which contain the information on how to construct queries.
They support the following basic query types, based on a specific set of constraints:
\begin{itemize}
    \item Count queries: number of matching patients
    \item Patient set queries: identifiers on matching patients
    \item Data queries: any kind of medical data about the matching patients
\end{itemize}

The constraints used can be:
\begin{itemize}
    \item Concept constraints: presence of a specific ontology item for a patient
    \item Value constraints: some numeric, text or date value satisfying some constraints
\end{itemize}

% additional features
Some features specific to some back end systems are supported only when using this system.
This is the case for systems implementing the tranSMART API v2:
\begin{itemize}
    \item Constraints based on studies / clinical trials
    \item Constraints based on pedigree / relation type
\end{itemize}
